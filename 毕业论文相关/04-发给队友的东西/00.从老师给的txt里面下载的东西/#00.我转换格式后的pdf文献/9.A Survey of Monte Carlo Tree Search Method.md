# A Survey of Monte Carlo Tree Search Method 笔记以及中文翻译概要

摘要：MCTS蒙特卡罗树搜索（Monte Carlo Tree Search）结合了精确的树搜索和随机采样的搜索方法，其在围棋和很多领域取得了瞩目的成就。本文对近五年的与其相关的文章做了总结，包括起源、变种、提高其性能的方法、应用领域做了介绍。

## 1 简介

MCTS是一个通过在决定空间内随机采样建立搜索树，从而得出最佳决策的方法，在AI领域已有广泛应用。
自其被提出的五年时间以来，其在围棋领域的应有鼓舞着人们。通过对其算法的不断改进人们已经了解到了其优点与缺点。
特点：

1. 他需要不断地进行统计，需要更好的计算能力支撑。
2. 他不需要特定领域的知识，而只需要直到规则，就可以在很困难的领域取得成功，但很多其他的方法都是需要特定领域的知识的。
作者调研了近五年的论文，可以提供一个对MCTS的初期印象

### 1.1 概述

MCTS的过程：
1. 寻找需要开采的节点，这里就涉及到了exploration（探测没采样的节点）和exploitation（开发已知的优秀节点）的平衡。
2. 在找到的节点上进行模拟，并更新存储的数据，包括对该节点该行动的奖励值更新和对该节点之前的历史节点的奖励值更新。
3. 在第二点中究竟应该怎样对第一点中找到的节点进行模拟呢？最简单的办法就是使其随机的选取一个行动，当然也有复杂一些的办法。
MCTS的最大的好处：
不需要对中间过程进行判断，也就是即使很有很有效的评估函数来评估游戏过程的得分，只要知道游戏规则，能在最终的节点判断出输赢即可，这可以有效的避免局部最优的影响。

### 1.2 重要性

MCTS在数字游戏和信息不完整的游戏中均取得了不少成就，在围棋上的成就最大。因为人类围棋选手与原有的电脑伪智能的差距太大了，而2012年之前的MCTS缩小了这个差距。然而其只能在9*9的棋盘上取得佳绩，像是19*19这样的正规棋盘上还没有出现超越，因为正规棋盘的搜索树分支太大，树的深度太深，导致计算量极大，而目前有没有完美的判断中间节点是否优秀的评估函数。
即使是这样，MCTS也已经成为了AI的很重要的研究方法和工具，只要引入一点点专业领域的知识，就可以极大地降级计算量，虽然在降低计算量的同时也引入了人为的知识可能不够准确的后果，但是整体来看还是可以接受的。同时人们也希望他可以和其他的算法进行杂交，并且作者相信他会成为主流工具。

### 1.3 目标

本文通过介绍算法本身、变种、性能提升、应用等知识，想要告诉读者MCTS很强！了解已有的MCTS应用，并且可以以这篇文章为索引将已有的算法结合到新的问题上使用。

### 1.4 文章结构

第一部分 概要
第二部分 介绍了一些专业术语和概念
第三部分 MCTS算法的具体细节
第四部分 MCTS的变种，从其基本方法引申出了很多其他方法
第五部分 提升其构造树能力的方法
第六部分 提升其模拟和记录数据能力的方法
第七部分 介绍其在游戏中和其他领域上的应用
第八部分 对MCTS如今状态、优缺点进行分析，对未来进行展望
第九部分 总结和致谢

本文丧心病狂的引用了240个参考文献，均为近五年来对MCTS的研究，在上面的每一部分里只是简要的对提到的内容进行介绍，如果有精力可以读一下参考文献。

在文章的最后有两个表分别是MCTS在游戏领域应用的各种方法及其优势，和在非游戏领域的对应表格。

## 2 背景

通过对决策理论、博弈论、蒙特卡罗和基于绑匪的方法的介绍，对MCTS的发展进行讲解。主要介绍了在博弈论中的应用。

### 2.1 决策理论

决策理论结合了概率论和效用理论，在不缺的情况下提供决策。涉及到了运筹学和马尔科夫链决策程序。

#### 2.1.1 马尔科夫决策程序（Markov Decision Processes）MDPs

对全部可观察的环境中的决策问题进行建模，具体如下

+ $$S$$：状态集合，$$S_0$$为初始状态
+ $$A$$：行动集合
+ $$T(s，a，s’)$$：在状态s的情况下，选取动作a到达状态s’的概率分布
+ $$R(s)$$：奖励函数
 建模实际上就是形成一个状态动作对的概率分布，得出在状态s时采取动作a的概率。
 而政策（在后文中指的是树的政策）则是想要找到最大收益的动作。

#### 2.1.2 部分可观测的马尔科夫决策程序

其比正常的MDPs多了一个条件

+ $$O(s，o)$$：状态s下，环境因素o可以被观测的概率
 无论是以上那种决策程序，最优决策都是确定的而不是按照概率分布的。

### 2.2 博弈论

博弈论涉及到了多智能体之间的交互。
每一次游戏都从初态开始运行，直到某个终态结束。每一个玩家在状态转换函数的引导下进行动作选择，同时评估函数要对每一次动作进行奖励赋值。例如最终胜利则+1，失败-1，平局0分等。
也可能会存在无法分出胜负的情况，每个玩家都在和对方的博弈中采取了最优的行动，但是同时无法取得胜利，这成为纳什均衡。他的计算量很大，通常无法解决。

#### 2.2.1 组合游戏

组合游戏的五点要求

+ 奖励和为0：最终状态胜利和失败的总奖励状态和为0（单独有正有负，总体上为0）
+ 信息可见：不存在隐藏信息
+ 无可变影响：没有按照一定概率决定游戏发展方向的因素
+ 动作按顺序：像下棋这样你一步我一步的，不存在同时启动等问题
+ 动作离散

像是象棋，围棋都属于组合游戏。多人的可结盟游戏也不属于组合游戏。组合游戏可以用来做AI的练习。

#### 2.2.2 真实世界的AI

真实世界所获得的奖励通常会延时到达，决策理论如下
Minimax（极小极大算法）：将对手多获得的最大奖励极小化，他假设对手总是能做出最好的决策，而总是在被动的应对对手的决策，例如伪AI五子棋中电脑总是不停的堵你的两个或三个连在一起的棋子一样。但是由于该算法并没有寻找自己能够获得的最大收益，所以往往不是自己活得最大收益的行动。同时还采用了α-β启发式算法进行剪枝。

### 2.3 蒙特卡罗方法

蒙特卡罗方法来自于统计物理，在游戏领域有很多应用。

![img](https://img-blog.csdn.net/20171216220749302?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYm93ZWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

$$Q$$：在状态$$s$$下选择$$a$$动作的平均得分
$$N (s,a)$$：状态$$s$$下选择$$a$$动作的次数
求和项：在状态$$s$$下选择$$a$$动作的总得分
最基本的蒙特卡罗可能会被困在局部最优，这就需要与后面所介绍的UCT算法结合，跳出局部最优。
即便如此，最基本的蒙特卡罗也可以根据历史的奖励值选取相对较好的行动。

### 2.4 基于强盗的方法

该方法是一个跳出局部最优的方法，在已经找到的较优的行动的开发，和目前认为不够优秀但可能对以后有很好的影响的行动的勘探，两方面进行平衡。

#### 2.4.1 遗憾

遗憾定义为当前状态的最优奖励之和减去真正获得的奖励之和。研究发现随着试验次数的增多，没有一种方法可以把遗憾控制在$$O(ln,n)$$的范围内，一个控制遗憾的有效方法如下

#### 2.4.2 上置信区间（UCB）

该方法在开发与探索中做了一个平衡

![img](https://img-blog.csdn.net/20171216224434645?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYm93ZWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

开发：第一项为针对土匪问题选择第j个手臂所获得的平均奖励，平均奖励越高约鼓励继续对其开发
探索：第二项鼓励探索，$$n_j$$代表对第j个手臂的探索的次数，$$n$$为总探索次数。对于第一项大的手臂，其$$n{_j}$$肯定也大，第二项趋近于0；对于第一项小的手臂，其被认为是对当前状态的价值不高的节点，$$n{_j}$$相对较小，随着$$n$$的增长，第二项将会变大，如果还不对其进行探索（$$n{_j}$$很小），第二项将会超过第一项的影响，从而鼓励对其探索，当对其开发之后$$n{_j}$$下降，如果此时该节点的探索没有获得很大收益将会暂缓对其的探索，直到n增大到需要重新对其探索为止。

## 3 蒙特卡罗搜索树

本节介绍了与蒙特卡洛搜索树相关的一系列算法
两个基本假定

+ 行动的价值可以通过随机模拟得出
+ 这些价值可以用来调整行动策略以选出最佳策略

通过逐渐的构建搜索树，对行动的价值进行评估，最佳行动将会越来越准确。
### 3.1 算法

蒙特卡罗搜索树的算法是通过迭代搜索策略来构建一个搜索树，直到找到最佳策略或达到了预先限定的时间或内存空间或是迭代次数的限制，根据找到的结果返回根节点的最佳动作。每一个节点代表一个状态，指向子节点的线代表一个动作。
迭代分为以下四步：

+ 选择：使用树策略从根节点开始采取行动，直到选择到一个最紧急的可扩展节点（不一定是叶子节点，也可能是含有部分未探索的行动的中间节点）

+ 扩展：在该节点上通过树策略选择一个可行的行动，并将其指向的节点添加到搜索树中。

+ 模拟：从新节点开始采用默认策略进行模拟，直到达到一个终端状态并得出奖励。
  
+ 奖励回传：模拟得出的奖励回传到新节点到根节点的每一个经由节点上，回传的奖励将会影响树策略。

  
    ![img](https://img-blog.csdn.net/20171218165421989?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYm93ZWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
    

上面提到了两个策略：

+ 树策略：在已有的树中从本节点选择行动，进入到下一个要探索的原有节点或新节点。树策略的形成是由一次一次的迭代并将奖励反向传播而形成的，它所选择的下一个动作的概率由回传的奖励影响。（从后文所讲述的UCT中可以看出还与访问次数有关）
+ 默认策略：在非终端节点上采用随机或者启发式算法寻找未探索过的动作和节点，并最终得出奖励评估。

何时迭代结束：
达到与限定于德计算预算时迭代结束。这是将会返回根节点的下一步动作，其指向的节点一般都是访问次数最多并且奖励最高的节点。

### 3.2 树的上置信区间UCT

UCT与UCB1的形式非常相近，知识前面多了2倍的常数系数，常数大于0。

![img](https://img-blog.csdn.net/20171218163620664?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYm93ZWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

$$n{_j}$$代表第$$j$$个动作的访问次数，访问次数为0时下一次访问的概率为1（若有多个0访问的动作则依次访问），这样做是为了保证每个节点在进行扩展时，每个动作都至少被访问了一次。其试图以此来平衡开采与探索，保证即使目前奖励低的节点也最终会被访问到，可以跳出局部最优。每一个节点同时保存其被访问的次数和获得的奖励，已决定下一次使用树策略时的动作选择概率。

### 3.3 算法实现

![img](https://img-blog.csdn.net/20171218165607841?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYm93ZWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

UCT的搜索算法：首先建立初始状态的节点，在迭代允许的次数或者时间和存储空间内进行迭代，首先使用树策略找到待扩展的节点并扩展，其次使用默认策略进行模拟并得出最终奖励，再利用奖励回传函数对扩展的 节点和之前的节点回传奖励，最终返回根节点的最好行动。

![img](https://img-blog.csdn.net/20171218165931490?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYm93ZWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

树策略：只要当前节点不是游戏终端状态，如果当前节点的所有动作未被完全拓展，则拓展本节点的其他动作并返回下一个新节点，否则选择一个最佳子节点。若到达了终端节点，则返回终端节点。

![img](https://img-blog.csdn.net/20171218171158328?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYm93ZWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

拓展本节点：选择本节点没有被访问的一个动作，并把该动作指向的节点添加到树中，同时记录下指向该节点的动作，返回该节点。

![img](https://img-blog.csdn.net/20171218171416518?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYm93ZWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

最好的子节点：UCT算法的精髓部分，用于在树策略中寻找下一个节点中使用。

![img](https://img-blog.csdn.net/20171218171622360?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYm93ZWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

默认策略：用于模拟时使用，随机选取当前节点的一个动作，直到模拟到最终的节点，并返回其终端状态对应的奖励。

![img](https://img-blog.csdn.net/20171218172520671?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYm93ZWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

奖励回传：从当前扩展节点到根节点的每一个节点的访问次数+1，奖励增加。

可以证明UCT经过多次迭代后会收敛到最优行动。

### 3.4

#### 3.4.1 启发式算法

蒙特卡罗搜索方法的最大优点就是不需要特定领域的启发式算法，但是如果采用了启发式算法会极大地降低模拟次数、减少分支。可以很快的得出结果，但是也会降低探索的空间，容易陷入局部最优。是否使用启发式算法，和启发式算法的使用强度需要权衡。
#### 3.4.2 非对称

搜索树的形状是非对称的，对于优秀的行动的探索更多。
#### 3.4.3 比较

比较MINIMAX（最小化敌方最大奖励）和MCTS可以看出后者不需要启发式算法，而前者必须要启发式算法，国际象棋在数据的维度上比围棋大的多，故使用启发式算法的MINIMAX更好，而MCTS在围棋中的表现更为优秀。

## 4 变种算法

传统AI适用于两个人对战的组合游戏，MCTS的变种算法已经可以适用于单人、多人、策略、实时、不确定性和同时移动的游戏。
### 4.1 Flat UCB

每一个叶子节点都作为单一的强盗手臂问题来判断，与Flat MC 不同，FlatMC没有建立树，把UCT的遗憾界提高了。

### 4.2 Bandit Algorithm for Smooth Trees (BAST)

使用了回报是平滑的的假设，可以识别出是否是最优分支，并且会不断拓展最优分支，并假设如果时间无限则只有最优分支会被不断拓展上去，而普通的UCT则会拓展全部的分支

### 4.3 Learning in MCTS

MCTS是强化学习的一种，可以应用于时间差异学习

#### 4.3.1 Temporal Difference Learning (TDL) 时间差异学习

TDL和MCTS都是根据状态对应的价值或者状态行动对来选取行动的。差异在于TDL是提前运行好全部的过程并保存下来，而MCTS是一边运行一边计算。

### 4.4 Single-Player MCTS (SP-MCTS)

单玩家模式的修正在UCB公式中添加了第三项，用于代表可能的偏差

![img](https://img-blog.csdn.net/20171220144832615?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYm93ZWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

根号内部第一项为方差，$$n_i$$为该节点访问次数，D为常数，第二项可以认为是对不常访问的节点，其统计偏差更大。该方法还使用了启发式算法。
如果单一使用平均值可能会掩盖好的行动策略，这里采用了方差，也就是如果有一次的奖励很大则会有更大的可能性访问这里，即使平均值不大。
单人玩家可能会有气特定的操作习惯，这也是不能应用到对所有玩家的策略中的。

### 4.5 Multi-player MCTS

在Minimax方法中，每一名玩家都希望自己的奖励最大化，敌人的奖励最小化。
而在多玩家应该采用max^n方法，对应于每个节点都存储一个奖励向量，在计算时整体考虑本联盟的奖励，从字面上理解为使得我方n的队友的奖励最大，这有可能对于本玩家并不是最大奖励。其将会考虑减少不利于友方玩家的影响，就好像都是自己的棋子一样。

对于多玩家的不同联盟情况有三种决策方法

+ Paranoid UCT：认为所有人都是敌对的
+ UCT with Alliances：有明确的联盟成员名单
+ Confident UCT：对每一个玩家进行搜索比较，确定是否可以形成联盟

对于多个合作的对手，可以看成单一有效的对手。

### 4.6 Multi-agent MCTS 和 Ensemble UCT

有些研究认为在默认策略的模拟阶段，采用并行化的多个智能体单独模拟并结合分析结果，产生的结果要优于只有一个智能体模拟的结果。

### 4.7 Real-time MCTS

MCTS在实时游戏中的应用不够优秀，因为其需要大量的时间进行模拟。

### 4.8 Nondeterministic MCTS

对应于非确定性的游戏并不是所有信息均可观测，大部分现实中的应用均不是全部可观测的。

#### 4.8.1 Determinization

可以通过对已有的偶然事件的结果进行分析，进而预测未来结果

#### 4.8.2 Hindsight optimisation (HOP)

事后优化，提前设置好每一个节点的奖励上限，在最终由人为选取较优的行动

#### 4.8.3 Sparse UCT

稀疏UCT，某些节点可能一个动作按照概率对应于多个孩子。

#### 4.8.5 Multiple MCTS

同时搜索多个树，综合得出最佳结论

#### 4.8.6 UCT+

不使用UCB的第二项，而是直接选取平均值最大的，这样有可能会导致陷入局部最优，但是速度上有很大的提升。

#### 4.9 Recursive Approaches

递归调用会记录下当前最佳操作和之后的一系列最佳操作串，我的理解是，对应于我的当前最佳操作，在模拟过程中同时得出敌方下一步的最佳操作，和我方应对的方法。如果敌方的最佳操作预测成功，则可以大幅度减少运算的代价。

## 5 树政策的增强

对于树政策的增强主要有两方面

+ 独立于特定应用领域：不需要任何领域的先验知识，均可以应用其中，一般只能做到微小的提高，只能对特定种类的领域起到提高作用。
+ 对于特定领域的应用：绝大部分对于特定领域的性能提升都是应用了特定领域的先验知识。

### 5.1 Bandit-Based Enhancements

基于绑匪问题的UCB算法是MCTS树策略搜索过程的核心，下面列出了一些对其提升的方法

#### 5.1.1 UCB1-Tuned

对其第二个参数的常数项系数人们已经研究出了一些较为稳妥的改进

![img](https://img-blog.csdn.net/20171220172852924?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYm93ZWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

$$s$$为第$$j$$个手臂被选取的次数，$$t$$为总实验次数。

#### 5.1.2 Bayesian UCT

贝叶斯UCT被认为可以极大地改善原来的算法，其提出了两个用于改进原有公式的看法，较为优秀的是

![img](https://img-blog.csdn.net/20171220174724070?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYm93ZWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

到目前为止已经有三个队原有公式的改进方案了，其一是添加第三项，其二的更该第二项的常数部分，其三就是本方法多乘了一项。无论是怎么改进，都是在原有公式基础上增加了方差这一项，不仅考虑平均值，加大了对最大值的考虑，从而进一步平衡开发与勘探。
### 5.2 Selection Enhancements

在树政策的选择节点方面，很多实验已经证明特定领域内的知识对提升其性能有很大的帮助。

#### 5.2.1 First Play Urgency

普通的树策略在某节点存在多个未探索的行动，决定选择哪一个未探索的行动时，采用的是随机的策略。本方法对每一个行动进行预评分，鼓励在早期的开发阶段对其开发。

#### 5.2.2 Decisive and Anti-Decisive Moves

决定性行动代表立刻取得胜利，反决定性行动代表阻止对手立刻取得胜利。
举个例子，对于五子棋而言，在每次探索之前，先检测我方是否有已经连成的四个字，并且还有下第五个子的空间，如果有则停止选择和模拟，该位置就是决定性行动，可以直接选择；而如果敌方已经有上述情况出现，则直接堵死敌方，成为反决定性行动。
然而对于一些复杂的像围棋一样很难有一招定胜负的情况，添加先验知识则会更加困难，即使是五子棋也会有出现多个反决定性行动的位置，也需要对出现的这几个位置进行探索已决定最佳操作。

#### 5.2.3 Move Groups

有时很多动作在最终获得了近乎相同的奖励，如果想要分清具体选择哪一个要耗费很大的计算量，这时可以在计算的初期对行动进行分组，使用UCB1选择行动组。

#### 5.2.5 Progressive Bias

渐进偏差，在节点的访问数量较小时，其统计值的偏差很大。如果在其访问初期人为按照先验知识设置其访问概率，并设置随着实验次数的增多，人工添加的部分占比越来越小，可以有效的在初期起到预热的作用。

![img](https://img-blog.csdn.net/20171220215038325?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYm93ZWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

Hi为人为对i节点设置的奖励，$$n_i$$为第$$i$$个节点的访问次数。

#### 5.2.6 Opening Books

将模拟过程中生成的数据存储下来，并形成一整套棋谱。

#### 5.2.7 Monte Carlo Paraphrase Generation (MCPG)

完全抛弃UCB1的，不选取每个行动的平均得分，而选取最大得分。
#### 5.2.8 Search Seeding

与5.2.5类似，为每一个状态赋初值，相当于在UCB标准公式上加上常数项，只不过这个常数项不像5.2.5一样会衰减。

#### 5.2.9 Parameter Tuning

UCB的公式里的勘探参数$$C_p$$等常数项均为人为设定的，对应于不同游戏该常数应该选取不同的值。需要人为实验后调整。

### 5.3 All Moves As First (AMAF)

其核心思想是，对于行动分支很大的模拟，不仅把模拟的结果更新到已有树策略上，还把模拟过程中的行动的得分记录到树策略上同一级的行动上。
例如坦克在向敌方坦克行进的过程中，此时有两个行动可以选择，一是继续行进，二是开炮，假设树策略选择了继续前进，在之后的模拟的默认策略上选择了开炮并得到了奖励，则不仅给当前的选择，即继续前进加分，也给当前节点的动作开炮加分。虽然本节点的动作开炮没有被本次选择，但是在下一次被选择了，故也加分。
#### 5.3.1 Permutation AMAF

当前状态选择了一系列动作的不同排列组合，到达了同样的终端状态，并获得奖励，该方法会对多种不同的组合赋分。

#### 5.3.2 α-AMAF

把标准UCT和AMAF按照一定的比例进行混合

![img](https://img-blog.csdn.net/20171220223018004?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYm93ZWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

#### 5.3.3 Some-First AMAF

在m次模拟后将5.2.5的先验概率截断。

#### 5.3.4 Cutoff AMAF

在前m次模拟中使用AMAF算法，此后的使用UCT。

#### 5.3.5 RAVE

将5.3.2中的α换成

![img](https://img-blog.csdn.net/20171220223616335?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYm93ZWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

#### 5.3.6 Killer RAVE

只有最重要的行动采取RAVE，对于普通行动减少计算量

#### 5.3.8 PoolRAVE

修改了MCTS的步骤，首先通过RAVE进行预热，选出当前状态最佳行动池，以概率$$P$$执行步骤$$m$$，否则执行默认策略。

### 5.4 Game-Theoretic Enhancements

如果某个状态在博弈论中的价值是确定的，则可以备份到树上，对应于普通的胜利平局失败的得分，计+1，0，-1分，但对于一些关键性的可以确认致胜或导致失败的步骤，可以计正无穷和负无穷。

#### 5.4.1 MCTS-Solver

当发现子节点均为失败时，本节点既可以认为是失败了，并且赋值为负无穷。
当发现子节点有一个成功，既可以认为本节点成功，并赋值为正无穷。这里是对单人玩家而言的。

#### 5.4.3 Score Bounded MCTS

设置悲观和乐观边界，认为奖励不得超过此值。

#### 5.5 Move Pruning

剪枝可以加快搜索效率，对于不会选取的行动就不再搜索。分为软剪枝和硬剪枝。

+ 软剪枝：被剪去的行动经过一段时间之后还可能被选择，可以防止最好的举措被过早的修建。
+ 硬剪枝：决定修剪后不会再访问该行动。

## 6 OTHER ENHANCEMENTS

本节介绍了除树策略之外的提升，例如默认策略，奖励回传，并行化等。

### 6.1 Simulation Enhancements

模拟的默认策略是随机选取，随着时间的增长会慢慢的遍布整个状态空间。如果则模拟过程中加上预先认为设定的先验知识，或通过学习得到的知识，会加快模拟，也会得到更多有效的模拟。

#### 6.1.1 Rule-Based Simulation Policy

基于一定认为设定的规则进行模拟。

#### 6.1.2 Contextual Monte Carlo Search

在选择下一步动作时参考之前的动作，形成连贯动作。

#### 6.1.3 Fill the Board

选择周围没有棋子的地方下棋，尽快填充棋盘。

#### 6.1.4 Learning a Simulation Policy

+ Move-Average Sampling Technique (MAST) ：将树策略中的行动得分应用于模拟的默认策略中
+ Predicate-Average Sampling Technique (PAST)：将状态动作对的得分应用于模拟中。

#### 6.1.5 Using History Heuristics

与6.1.4类似，在选择过程中选择了行动a，则模拟也选择行动a

#### 6.1.6 Evaluation Function

也可以通过评估函数进行模拟。普遍是在模拟初期使用评估函数，过渡到根据历史知识选择最佳行动。

### 6.2 Backpropagation Enhancements

#### 6.2.1 Weighting Simulation Results

对反向传播的奖励进行加权。因为模拟时间越久越准确，所以后来模拟的奖励权重更高。因为模拟越短越准确，所以模拟越短权重越高。

#### 6.2.2 Score Bonus

对于胜利失败不止设置+1和-1，而是设置在+1到-1的区间内部，用于区分大胜小胜。

#### 6.2.3 Decaying Reward

对应于当前节点返回的奖励值最大，此前的每一个节点的奖励返回值都乘以一个小于一的常数。

### 6.3 Parallelisation

![img](https://img-blog.csdn.net/20171221183914163?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYm93ZWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

由于MCTS的每次模拟都具有独立性，因此可以采用并行化来加快运行速度。


#### 6.3.1 Leaf Parallelisation

叶子节点进行模拟时同时进行多个模拟
缺点：要等待最长的模拟结束后才能开始新的搜索。

#### 6.3.2 Root Parallelisation

对于已有的搜索树，并行的从根节点开始并行的先采用树策略选择要拓展的节点再采用默认策略进行模拟。

#### 6.3.3 Tree Parallelisation

树并行化考虑到多线程对资源的访问问题，引入了全局锁和局部锁。这在模拟过程远长于树搜索过程的时候是可行的。

### 6.4 Considerations for Using Enhancements

某些领域中，增强有很好的效果，某些领域中无法提升计算速度，甚至还会产生出错误的决策，这就会适得其反。因此对于MCTS的各类增强要结合特定的领域来使用才更加有效。

## 7 APPLICATIONS

在本节中，主要介绍了MCTS在围棋，连接游戏，其他组合游戏，单人游戏，综合游戏（非应用于单一领域），实时游戏，非决定因素的游戏，非游戏领域的应用。
在每一领域都介绍了代表性的游戏的玩法，有很多游戏是国内没有接触过的，理解起来有些困难。同时也介绍了特定领域的知识，现有的应用，并指明了未来会朝着什么方向进行完善。

## 8 SUMMARY

对本篇文章做一个总结，从本文附录的两张表中可以看出UCT是MCTS使用最频繁的方法，在围棋领域的应用最多，在其他以组合游戏为主的领域也有很广泛的应用。

### 8.1 Impact

MCTS有效的解决了中间状态的评估问题，在游戏领域成为了强大的电脑玩家，在非游戏领域也有很强的应用。

### 8.2 Strengths

其一个很大的优势是在不知道游戏知识而只知道游戏规则时可以形成良好的策略。
整合人类已有知识，结合启发式算法，可以使得效率大大提升。
其另外一大优势是，即使先验知识有错误的引导，MCTS也能够通过大量的模拟来消除他的影响。

### 8.3 Weaknesses

缺点在于对于拥有大量分支结构的问题，其实时性非常差，对应于很多问题只能够给出相当浅的搜索树。如果其搜索的算法没有从本质上改变，则很难对复杂实时问题进行应用。

### 8.4 Research Directions

未来的研究方向主要为：

+ 总体上提升MCTS性能
+ 在特定领域提升MCTS性能
+ 理解其搜索过程内在是如何运行的

[TOC]

---

版权声明：本文为CSDN博主「bowean」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。

[原文链接](https://blog.csdn.net/bowean/article/details/78808584)