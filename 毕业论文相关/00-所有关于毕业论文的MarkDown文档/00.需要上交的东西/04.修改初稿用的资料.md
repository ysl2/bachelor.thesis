# 毕业论文修改版

>  UCT是MCTS的选择函数的一个特例，不能和MCTS混淆在一起介绍。

## 零、蒙特卡洛规划（Monte Carlo planning）

### （一）单一状态蒙特卡洛规划：多臂赌博机（multi - armed bandits）

![image-20200410195547606](C:\Users\YSL\AppData\Roaming\Typora\typora-user-images\image-20200410195547606.png)

权衡**探索**与**利用**

### （二）上限置信区间策略（Upper Confidence Bound Strategits，UCB）

![image-20200410203153342](C:\Users\YSL\AppData\Roaming\Typora\typora-user-images\image-20200410203153342.png)

### （三）蒙特卡洛树搜索（Monte Carlo Tree Search）

#### * UCT（Upper Confidence Bounds on Trees）



## 一、Monte Carlo方法

### （一）定义与性质

基于随机抽样

### （二）来历

1777年法国Buffon提出用投针实验的方法求圆周率π，这被认为是蒙特卡罗方法的起源。

20世纪40年代（由S.M.乌拉姆和J.冯·诺伊曼在20世纪40年代为研制核武器而首先提出。

1987年，鲁斯·艾布拉姆森（Bruce Abramson）在他的博士论文中探索了这一想法，称它“展示出了准确、精密、易估、有效可计算以及域独立的特性“。他深入试验了井字棋，然后试验了黑白棋和国际象棋的机器生成的评估函数。

1992年，B·布鲁格曼（B. Brügmann）首次将其应用于对弈程序，但他的想法未获得重视。

## 二、MCTS

### （一）定义与性质

Monte Carlo Tree Search，蒙特卡洛树搜索

基于采样得到结果，而并非穷尽式枚举。

### （二）来历

2006年，雷米·库洛姆（Remi Coulom）描述了蒙特卡洛方法在游戏树搜索的应用并命名为蒙特卡洛树搜索。

### （三）构成

#### 1.选择（Selection）

让游戏树向最优的方向扩展，这是蒙特卡洛树搜索的精要所在。

子结点的主要困难是在较高平均胜率的移动后对深层次变型的利用和对少数模拟移动的探索二者中保持某种平衡。

#### 2.扩展（Expansion）

#### 3.仿真（Simulation）

又称playout或者rollout，用随机策略进行游戏，又称为playout或者rollout。

#### 4.反向传播（Backpropagation）

使用随机游戏的结果，更新从*C*到*R*的路径上的结点信息。每一个节点的内容代表胜利次数*/*游戏次数。

## 三、UCT

### （一）定义与性质

Upper Confidence Bound Apply to Tree，上限置信区间算法。

如果无限算力，UCT将会收敛到MiniMax。

### （二）来历

UCT基于奥尔（Auer）、西萨-比安奇（Cesa-Bianchi）和费舍尔（Fischer）提出的UCB1公式。

2006年，匈牙利国家科学院计算机与自动化研究所高级研究员列文特·科奇什（Levente Kocsis）和阿尔伯塔大学全职教授乔鲍·塞派什瓦里（Csaba Szepesvári）将MCTS与UCB公式结合，开发了UCT算法。

### （三）构成

UCT  = UCB + MCTS。由于UCT本身就是MCTS的特殊情况，因此也有MCTS的四个步骤。

UCT 算法就是在设定的时间内不断完成从根节点按照 UCB 的指引最终走到某一个叶节点的过程。而算法的基本流程包括了选择好的分支（Selection）、在叶子节点上扩展一层（Expansion）、模拟对局（Simulation）和结果回馈（Backpropagation）这样四个部分。

UCT 树搜索还有一个显著优点就是可以随时结束搜索并返回结果，在每一时刻，对 UCT 树来说都有一个相对最优的结果。

#### 1.选择（Selection）

UCT 树是不对称生长的，其生长顺序也是不能预知的。它是根据子节点的性能指标导引扩展的方向，这一性能指标便是 UCB 值。

UCB公式

“利用”（Exploitation）和“探索”（Exploration）机制。

![image-20200410204046273](C:\Users\YSL\AppData\Roaming\Typora\typora-user-images\image-20200410204046273.png)

![UCT](https://www.chessprogramming.org/images/5/50/UCTFormula.jpg)

Xj是孩子的胜率

n是父母的访问次数

nj是孩子的访问次数

C是常数，理论上是Math.sqrt(2)，实际中通常可以加权选择。C小偏重利用；而 C大则重视探索。需要通过实验设定参数来控制访问节点的次数和扩展节点的阈值。

第一部分是“利用”，第二部分是“探索”。

$$
\frac{W_{i}}{N_{i}} + \sqrt{\frac{C \times lnN}{N_{i}}}
$$

WiWi：子节点获胜的次数；
NiNi：子节点参与模拟的次数；
NN：当前节点参与模拟的次数
CC：加权系数。

在实际编写代码时，当前节点指的并不是具体的着法，而是当前整个棋局，其子节点才是具体的着法，它势必参与了每个子节点所参与的模拟，所以`N`就等于其所有子节点参与模拟的次数之和。当`C`取1.96时，置信区间的置信度达到95%，也是实际选择的值。

UCB:  是指UCB公式 （Upper Confidence Bound），公式是这样的

​             Vi + C*sqrt(ln(n)/Ni)

![image-20200410193823610](C:\Users\YSL\AppData\Roaming\Typora\typora-user-images\image-20200410193823610.png)

UCT 算法：UCB for Tree的算法，最经典的蒙特卡罗树搜索算法

​              UCT = MCTS + UCB

UCB1： 一种简单而广泛使用的UCB公式

​           Vi + sqrt(2*ln(n)/Ni)

UCB公式比UCB1公式多了一个C，而这个C有什么用呢？根据我的了解，这个C是一个常数，C的值越大越偏向于bfs（广度优先搜索），而C的值越小越偏向于dfs（深度优先搜索）。

UCT算法是蒙特卡洛树搜索算法的进阶，结合了UCB公式。alphago就是以此类算法为基础的。可以用于完备信息博弈当中，非完备信息游戏中使用UCT算法或许有效，但以目前研究状况看效果有限。

####  2.扩展（Expansion）

#### 3.仿真（Simulation）

#### 4.反向传播（Backpropagation）

## 附：MiniMax

时间复杂度：O（b的m次方）

空间复杂度：O（b * m）（深度优先搜索）