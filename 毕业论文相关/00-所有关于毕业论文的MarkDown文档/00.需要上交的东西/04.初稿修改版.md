## 一、绪论 1

## 二、棋类游戏人机博弈的基本方法 1

### （一）棋盘表示与走法产生 2

### （二）搜索算法 2

## 三、Monte Carlo Tree Search算法概述 6

Monte Carlo Tree Search算法是应用于树结构的一种启发式搜索算法。此算法延续了极小极大算法的博弈树概念，基于Monte Carlo方法多次随机模拟实验的特点。与Monte Carlo方法不同的是，由于只能在树结构中使用，因此MCTS算法的应用场景更少。在分析MCTS算法之前，需要对Monte Carlo方法进行说明。

### （一）Monte Carlo方法 6

Monte Carlo方法与Monte Carlo Tree Search算法在思路上有继承性，但在具体实现中不同。Monte Carlo方法实际上是一种基于随机抽样的统计学模拟方法，是二十世纪四十年代中期由于科学技术的发展和电子计算机的发明，而被Bruce Abramson在1987年提出的一种以概率统计理论为指导的一类数值计算方法。这种方法旨在通过使用随机数来解决计算问题。

比如求圆周率Π时，在正方形中随机布点。当布点的次数足够多时，这些点将均匀地分布在正方形范围内，这时只需计算出圆内与圆外点的个数，即可估算出Π的值：

![img](file:///C:\Users\YSL\AppData\Local\Temp\ksohtml15352\wps1.jpg) 

Monte Carlo方法的意义在于，让电脑帮助人们进行多次模拟重复计算，可以解决大量手工模拟的繁琐。这种方法具有普适性，不仅在棋类游戏中可以使用，在数据分析时也可以使用这种多次模拟且具有随机性的实验方法。

### （二）Monte Carlo Tree Search算法 7

Monte Carlo方法对于组合博弈完全适用，只要对可能的走法进行随机抽样后一直玩到游戏结束即可。但这种方法由于缺乏理论指导，很有可能在迭代执行很长时间后，最后选出的子节点依然不是最优的。1992年，B·布鲁格曼（B. Brügmann）首次将Monte Carlo方法应用于对弈程序，但对弈效果并不出色。

2006年，雷米·库洛姆（Remi Coulom）提出了一种新的方法：将Monte Carlo方法与博弈树搜索结合，并命名为蒙特卡洛树搜索（Monte Carlo Tree Search，简称MCTS）。MCTS算法通过模拟得到大部分节点的价值，然后下次模拟的时候根据价值有策略地选择值得利用和值得探索的节点继续模拟，在搜索空间巨大并且计算能力有限的情况下，这种启发式搜索能更集中地、更大概率找到一些更好的节点。

#### 1．Monte Carlo Tree Search算法基本原理

MCTS算法的步骤是：选择（Selection）与扩展（Expansion）、模拟（Simulation）、反向传播（Backpropagation）。在MCTS进行过程中，这些步骤会重复多次，直到算力到达极限才停止。

![img](file:///C:\Users\YSL\AppData\Local\Temp\ksohtml13752\wps1.jpg) 

上述步骤都是针对节点进行，而每一个节点，都包括一种节点状态。节点状态分为：已访问节点、已完全展开节点、未完全展开节点、终端节点。

 ①已访问的节点：指在MCTS搜索过程中，节点的信息被更新过。信息更新的过程由后述的反向传播步骤完成。

 ②已完全展开的节点：指当前节点下的所有子节点都至少被访问过一次。

 ③未完全展开的节点：指当前节点仍存在没有被访问过的子节点，或者仍存在未产生的子节点。未产生的子节点一定是未被访问的节点。 

④终端节点（叶节点）：指当前节点对应的局面是确定的，且无法继续下棋。确定的状态包括：电脑胜利、玩家胜利、平局。对于五子棋来说，只要棋盘上仍存在空位置，就不是终端节点。

##### (1)选择（Selection）

选择步骤的目的是在树中找到一个最好的值得探索的节点。从根节点出发，深度遍历整棵博弈树，直到获得一个值得探索的子节点。由于MCTS会多次进行模拟，选择步骤也会被执行多次。

在算法进行过程中，根节点会存在以下几种状态： 

①MCTS开始时的根节点：其子节点还未产生，因此需要随机选取一个子局面作为值得探索的节点。

②已经至少进行了一次MCTS搜索的根节点； 

a. 根节点没有完全展开：虽然已经存在部分子节点，但是仍有节点没有展开。此时应优先选择未被展开的子节点作为值得探索的节点，而不是在目前的已经展开的子节点中选择。 

b. 根节点已经完全展开：此时所有子节点都是已访问状态。在这种状况下，需要根据某种策略计算获取一个值得探索的子节点。

#####   (2)扩展（Expansion）

扩展步骤的目的是在上一步中选中的节点中创建一个新的子节点。一般创建子节点方法是查找所有子局面，并随机一个未与之前选择过的局面重复的子局面生成子节点。

#####   (3)模拟（Simulation）

此步骤又称playout或rollout，目的是评估当前节点的价值。作用类似于极小极大算法的估值函数。由于采用随机评估，如果只进行一次，结果将非常不准确，这也是MCTS需要进行多次模拟的原因。随着执行次数增加，博弈树会变得越来越庞大，算法的可信度就越高。

实现模拟的步骤是对上一步产生的节点的棋盘进行随机落子，直到把整个棋盘填满，或者分出了胜负，最后返回模拟下棋的结果。在进行下棋之前，需要先判断一下当前节点是否是终端节点，如果是终端节点，就不进行模拟下棋，直接返回真实结果。此步骤体现了Monte Carlo方法的随机性。模拟步骤没有改变节点的定位，在模拟结束后，当前节点依然是通过扩展产生的那个节点。

在执行落子之前，需要重新拷贝一份当前的棋盘，否则模拟后将会对目前的棋盘产生影响，使下一次模拟结果出错。

##### (4)反向传播（Backpropagation）

反向传播的目的是将当前节点的模拟结果传达到父节点，并让父节点继续向上传播，直到传播到根节点。通过反向传播，根节点可以得知子节点在若干步后的情况，并根据情况判断这个子节点是否值得继续探索。

在算力或搜索时间达到极限时，MCTS最终将选择胜率最大的子节点作为下一步走法。

2.Monte Carlo Tree Search算法的伪代码表示

上述四个步骤可以分为两个不同的策略：

Tree Policy：从已包含在搜索树中的节点中选择或创建叶节点（选择与扩展）。

Default Policy：从给定的非终端状态进行随机游戏，以生成值估计（模拟）。

反向传播步骤不使用策略，而是更新通知下一次Tree Policy需要用到的节点统计信息。

通过选择过程，可以让博弈树向最优的方向扩展，这也是MCTS的精要所在。但困难在于，MCTS算法达到搜索目的，必须能够选出最值得探索的节点。为了做到这一点，需要在较高平均胜率的移动后，在对深层次变型的利用和对少数模拟移动的探索，这二者中保持某种平衡。第一个在游戏中平衡利用与探索的算法被称为UCT（后叙）。

### （三）上限置信区间（UCB）算法 9

对于组合博弈，可以抽象成多臂赌博机问题：一个单一状态有k种行动，每次以随机采样形式采取一种行动，得到一定的回报。我们需要知道下一次拉动赌博机的哪一个臂，才能获得最大回报。为此，可以尽量多尝试回报高的臂，但是也需要兼顾那些还没有尝试过或者尝试次数比较少的的臂。此类问题需要兼顾探索与利用。对于这种情况，UCB（Upper Confidence Bounds）算法可以很好的解决。由Auer、Cesa-Bianchi和Fischer于2002年提出的最简单的UCB算法，被称为UCB1算法：

$$
UCB1=\bar{X}_{j}+\sqrt{\frac{2 \operatorname{In} n}{n_{j}}}
$$

在UCB1算法中，$$\bar X_j$$是平均奖励，$$n_j$$是当前臂被尝试的次数，n是到目前为止的总尝试次数。xj鼓励去选择回报高的臂，而**右边的项**则偏向于去选择访问次数较少的臂。 UCB1值表示xj的置信区间上限，反映的是xj最大期望回报。在棋类博弈中，此值能够反映某种走法是否是一个好的走步。

### （四）上限置信树（UCT）算法 10

虽然通过MCTS算法可以解决博弈问题，但是由于MCTS方法在没有选择指导时，树的扩展层数较少，不利于最优解的获取。因此人们想到将UCB算法加入MCTS过程。2006年，Levente Kocsis和Csaba Szepesvári将MCTS算法与UCB1算法结合，开发了上限置信树（Upper Confidence Bounds Apply to Tree，简称UCT）算法。

#### 1.UCT算法与MCTS算法的区别

UCT算法是将UCB算法思想用于MCTS算法的特定算法，与只使用MCTS算法不同，区别在于Tree Policy中，子节点的选择方式是根据UCB的上限置信索引值进行选择。如果子节点没有被访问，则子节点的UCB1值为正无穷大。如果子节点被访问过，则子节点的奖励值可以根据UCB算法确定。最终选择UCB值最大的子节点作为最优子节点。

由于UCB算法本身对于探索和利用的平衡，所以利用UCB算法作为理论指导的UCT算法也具有该特点。它在探索和利用之间找到平衡，使得在模拟过程中表现良好的节点能够被更多次的访问，而一些不理想的节点在少量访问后就不再被访问。这样做的优势是对那些较好的节点，可以更加深入的进行探索，以保证最终的选择更加接近最优解。因此我们在模拟过程中往往以UCT算法代替单纯的MCTS算法。

#### 2.公式

$$
UCT=\bar{X}_{j}+2 C_{p}\sqrt{\frac{2\ln n}{n_{j}}}
$$

此公式用于解决纯MCTS中选取子节点的问题。通过计算，获取具有最大UCT值的子节点，则此节点为最值得探索的节点。此公式中，n是当前节点被访问的次数，nj是子节点j被访问的次数，Cp是一个大于0的常数。

①当存在未被探索的子节点时，nj=0，此时对应的UCT值为无穷大，无论已探索过的节点的UCT值有多大，依然会优先探索未被探索的子节点。只有所有节点都至少被探索过一次，才会真正按照最优子节点的顺序来选择。这一步的思路与上述MCTS算法相同。

②如果当前节点的所有子节点均被探索过，子节点被访问时，探索项分母增加，整体UCT值会降低。如果另一个子节点被访问，则分子增加，因此未被访问的节点的探索值增加。通过此公式，可以平衡探索与利用的关系。

③通过调整Cp值的大小，可以调整探索与利用的比例。Kocsis和Szepesvári建议的Cp值为1 / 根号2，此值仅适用于最终奖励值在[0, 1]区间内的情形。如果超过此区间，可能需要调整Cp值。

④对于博弈树的任意一个节点v，其每个子节点vi都有两个值：被访问次数N(vi)，模拟奖励Q(vi)，Q(vi) / N(vi)是子节点vi的胜率，对应上述公式中的Xj。因此上述公式也可以被描述为：
$$
\operatorname{UCT}\left(v_{i}, v\right)=\frac{Q\left(v_{i}\right)}{N\left(v_{i}\right)}+c \sqrt{\frac{\log (N(v))}{N\left(v_{i}\right)}}
$$
在反向传播过程中，节点的Q值与N值会被更新，每进行一次反向传播，传播路径上的节点的N值就会加1。而Q值则反映的是模拟的输赢情况。如果模拟胜利方是当前节点对应的那一方，则Q增加，反之则减少。

#### 3.最终节点的选择

UCT算法有多种选择最终结果的方式：选择最大胜率的节点或选择访问次数最多的节点。大多数情况下，这两种方式得到的是同一节点。但也存在不同节点的情况。在围棋程序ERICA中，如果通过这两种方式得到的不是同一节点，将会继续搜索以解决此潜在差异。本设计中采用最大访问次数作为最终获得子节点的标准。

#### 4.UCT算法过程示例（以2 * 2棋盘为例）

#### 5．UCT算法与极大极小算法的异同点

UCT算法与极小极大算法的相同点：两种方式都采用深度遍历。并且都通过某种评估手段缩小博弈树。 

UCT算法与极小极大算法的不同点：

①局面评估方式不同：极小极大算法的评估是通过估值函数实现，而UCT算法的评估是通过Default Policy步骤实现。

②剪枝方式不同：在UCT算法中，通过UCB1函数的判断实现自动化剪枝。极小极大算法通过alpha-beta剪枝。

③UCT算法不依赖特定的棋类知识，只要在Default Policy步骤中加入棋类规则即可。而极小极大算法需要程序员对棋类了解，并且人工设置某种局势的优劣。

实际上，根据Kocsis和Szepesvári在其论文"The Nonstochastic Multiarmed Bandit Problem"中证明，如果在算力与时间无限大的情况下，UCT算法的值将收敛到极大极小算法的值。

## 四、五子棋程序实现 16

### （一）UCT算法的伪代码实现 16

### （二）五子棋界面的实现 22

## 五、系统测试与分析 24

### （一）确定测试方案 26

### （二）不同测试方案下的结果 26

### （三）总结测试效果 27

### （四）提出解决方案 28

### （五）对局情况演示 28

## 六、展望 29

## 参考文献 30

UCB1：Auer, P.; Cesa-Bianchi, N.; Freund, Y.; Schapire, R. E. (2002). "The Nonstochastic Multiarmed Bandit Problem". *[SIAM J. Comput.](https://en.wikipedia.org/wiki/SIAM_Journal_on_Computing)* **32**(1): 48–77. [CiteSeerX](https://en.wikipedia.org/wiki/CiteSeerX) [10.1.1.130.158](https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.130.158). [doi](https://en.wikipedia.org/wiki/Digital_object_identifier):[10.1137/S0097539701398375](https://doi.org/10.1137%2FS0097539701398375).

![image-20200411175354945](C:\Users\YSL\AppData\Roaming\Typora\typora-user-images\image-20200411175354945.png)

![image-20200411175419520](C:\Users\YSL\AppData\Roaming\Typora\typora-user-images\image-20200411175419520.png)

![image-20200411175252632](C:\Users\YSL\AppData\Roaming\Typora\typora-user-images\image-20200411175252632.png)

```python
def MCTS_search(游戏状态s0):
    根据游戏状态S0创建根节点v0
    while 在算力或时间允许范围内:
        子节点vi = tree_policy(v0)
        模拟结果 = default_policy(vi的游戏状态)
        backup(子节点vi, 模拟结果)
    return best_child(v0)
```

