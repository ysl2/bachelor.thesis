# **基于Monte Carlo方法的五子棋算法设计与实现**



**[计划完成时间] ： 两个月
[计划撰写字数（千字）]： 8000**

[TOC]

## **1.本选题研究的理论意义和使用价值**

五子棋是一项历史十分悠久的博弈游戏。从古发展至今，五子棋已经成为一项正式比赛。在20世纪40年代时，人们一直深信计算机无法进行博弈，即计算机无法在五子棋上胜过人类的判断。直到计算机第一次打赢人类后，这一固有观念被打破。直到21世纪初，计算机五子棋算法已经经过了很多方式的更迭，并产生出许多优秀的算法方案。而其中一种方案，则是基于蒙特卡洛树搜索的五子棋算法。

蒙特卡洛是一种多次模拟的方法，如果问题可以描述成某种统计量的形式，那么就可以用蒙特卡洛方法来解决；遗传算法等则适用于大规模的组合优化问题（选址问题、排班问题、管理调度、路线优化）等，以及复杂函数求最值、参数优化等。

而蒙特卡洛树则是一种在一些广泛随机样本中获取权重较高的样本，并作出决策的一种模拟统计算法。通过这种算法，人们只能近似地得到最优解，却无法真正地获取最优解。但是有很多时候，我们并不需要获取最优解，而是只要满足在一定误差范围内的解就可以。比如有限双人零和回合制博弈。而五子棋博弈就是一种有限双人零和博弈。如果我们将五子棋博弈看成是一种实验，那么研究蒙特卡洛的算法的五子棋实现方式，不仅可以验证蒙特卡洛树算法的实际作用，还可以提升计算机的智能化程度。

通过蒙特卡洛树方法，人们在很多情况下可以用计算机的模拟来代替复杂的数学推演过程。比如蒙特卡洛树可以用计算机模拟的方式代替手工实验。这使原本需要费时费力的事情变得十分简单。

## **2.本选题国内外研究现状**
五子棋理论上来说只要计算机每一步的胜率都能超过50%，则可以保证胜利。但是实际上五子棋并不是一种双方胜率相同的博弈方式。通过大量资料与数据，我们可以得出结论：先手者可以达到必胜的局面。针对这种双方不平衡的局面，在一些五子棋人工智能比赛，如Gomocup五子棋比赛中往往会规定一些规则削弱先行方的优势。比如交换规则、禁手规则、泡沫规则、限制棋盘大小规则等。

对于类似五子棋这种有限双人零和回合制博弈，它们都会有三个限定条件：1.在任何时间点，玩家之间都只存在有限的互动方式。2.游戏只能有两个人参与。3.玩家轮流进行动作。4.如果一方胜利，则另一方必定失败。双方的总收益和为零。当我们不知道对方的棋艺水平时，可以采用一种激进的策略——Minimax极小化极大算法作为计算机的博弈算法。极小化极大算法是指：每次都假设对手能够通过作出最优决策使我们的收益最小，在这种情况下最大化己方收益。在这种情况下，我们不需要知道对方是专业的大师还是普通玩家，只要我们每次落子都是最优的位置即可。此算法需要展开整个博弈树，这使生成的博弈树由于体积过于庞大而难以计算。必须在传统的极大极小算法上进行优化

最常见的两种优化措施是，一是限定博弈树的深度。这样就需要一个评估当前博弈状态的函数。二是通过Alpha-beta剪枝算法将博弈树中一开始就不可能是最优解的点排除。这样返回的最优值结果是和极小化极大算法相同，但是却通过减少搜索空间提升了搜索效率。而如果我们再将判断标准降低，将“获取最优点”变成“获取相对不错的点”，就变成了蒙特卡洛树搜索。

蒙特卡洛树搜索（MCTS）则会进行多次模拟博弈，并“尝试”预测最优行动。与极小化极大算法相同的是，蒙特卡洛也会向下遍历博弈树。但是蒙特卡洛会在遍历某一个节点的时候通过一个权值来筛选最不可能是最优解的值，并且根据这个权值还能改变遍历的次序，优先遍历最有可能是最优解的点。这个权值是由树的上限置信区间函数（UCT函数）确定的：
$$
\operatorname{UCT}\left(v_{i}, v\right)=\frac{Q\left(v_{i}\right)}{N\left(v_{i}\right)}+c \sqrt{\frac{\log (N(v))}{N\left(v_{i}\right)}}
$$
UCT函数主要包括三个变量。$$Q\left(v_{i}\right)$$是子节点的总模拟奖励，$$N\left(v_{i}\right)$$是子节点的总访问次数。$$N\left(v\right)$$是父节点的总访问次数。而我们又可以将这个函数划分为两部分：$$\frac{Q\left(v_{i}\right)}{N\left(v_{i}\right)}$$开发分量和$$\sqrt{\frac{\log (N(v))}{N\left(v_{i}\right)}}$$探索分量。开发分量是每一节点被评估的胜率，探索分量则是对胜率误差的矫正。比如如果一开始某一个点的胜率很低，但是这不能说明此点后续不能成为“值得考虑的点“，因此增加探索分量用来纠正算法的误判。常量c则是对于胜率和矫正误判之间的权衡，既不能过分纠正，也不能全部排除暂时不可能是最优的点。并且在完成一个节点的遍历之后，将模拟的结果反向传播到此节点的父节点。每一级都像这样传回，就可以得到最接近最优值的点。我们一般会使用静态估值函数作为探索分量。静态估值函数原理是选取尽可能多典型的棋盘局势的特征，并将这些特征作为评估当前棋势状况的标准。

但是这种方法仍然存在一定缺点：1.首先这对于设计人员必须要更加深入了解五子棋的玩法，能够对各种复杂的情形做出准确的评估，并将这种评估进行量化处理。2.如果在程序中对大量的棋势进行存储，必将消耗很多内存资源，并且在UCT函数调用这些棋势的估值时，浪费的时间也会相应增加。这样，算法很有可能无法在有限的规定时间内完成搜索要求。

## **3.围绕本选题已做哪些准备工作，计划再做的工作**

通过阅读和整理文献并结合代码试运行，我已经：

1.基本理清了五子棋的博弈逻辑。目前主要的五子棋人工智能比赛规则（以gomocup为例）最早是基于20 * 20大小棋盘的无禁手规则。在这种规则下先行方优势很大。2009年，无禁手规则被标准化，规定为15 * 15的棋盘大小、长连不计入输赢（长连是指5个以上的棋子连成一条线）。2016年，规则被进一步限制。执黑子的先行方有禁手且棋盘采用15 * 15大小，并要求使用专家提前准备好的平衡开局。在本次设计中，为了排除其他项的干扰，使算法能够最大程度地发挥，我们采用gomocup中的Free-Style规则：棋盘为15 * 15，电脑为先手方、不做禁手、长连算赢。

2.明确五子棋的判断逻辑。五子棋最终判断胜负的依据是，根据水平、竖直、45°和135°的线上是否有下一步落子能构成五子连珠的位置。如果有，则已经分出胜负。所以可以通过提前若干步预判棋局的当前状况来提高算法的智能度。

下一步计划再做的工作：

1.明确返回值类型与参数列表、明确类与类之间的调用关系、明确每个类实现的功能。目前我简单地分成了三部分：五子棋界面、五子棋的落子逻辑、计算机判断策略。随着研究的不断深入，这个初步的框架也会逐渐扩展。

2.写出蒙特卡洛树搜索的伪代码，并根据不同代码的功能创建方法，实现类内方法调用。

## **4.计划在哪些方面有所突破**

虽然采用了蒙特卡洛方法，但是在一个棋盘上，每走一步对应的近似最优解的数量依然是非常庞大的。因此我们必须针对计算机的五子棋博弈策略进行优化。优化分为两个方面：1.快速计算出博弈树中每个子节点的权值；2.针对返回的权值，算法能够及时改变搜索次序，优先搜索比较符合要求的节点，使在设定最大搜索时间内能够更接近于最佳点。而这两个优化点，其本质上来说依然是与静态估值函数，我们希望能够尽量优化这个函数，使计算机计算出的近似最优解能够更接近于真正最优解。


## **5.主要参考文献** 

