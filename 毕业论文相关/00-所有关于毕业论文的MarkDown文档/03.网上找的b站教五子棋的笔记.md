# MLDN 五子棋（按ctrl + Home可返回顶部）

[TOC]

## 一、Swing 知识准备

### 1.1 Swing 的概念
Swing 是在java 的基础图形化用户界面AWT 的基础上扩展的API 集。
Swing 的功能：通过java 代码编写窗口程序，创建图形化用户界面（GUI）。
Swing 可以创建窗体，面版，在窗口中导入或绘制图片，或输入文本信息，
结合java 的JDBC或IO操作可以实现数据的保存。（记事本的保存功能）

### 1.2 JFrame 类

JFrame 是创建窗体的swing 类，用来创建一个图形界面的原始窗口，并设置其大小，
位置等属性，是swing 编程的基础类之一。

#### 1.2.1 JFrame的主要方法

```java
1.setTitle(String title)
    //设置窗体标题。
2.setSize(int width, int height)
    //设置窗体大小。
3.setLocation(int x, int y)
    //设置窗体位置。这个坐标对应的是窗体左上角的坐标
4.setResizable(boolean flag)
    //设置窗体是否能被用户缩放。（锁定窗口大小不让用户最大化）
5.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE)
    //通过静态字段设置窗体关闭时的动作。例如此实例就是在窗口关闭时同时结束程序。
6.setVisible(boolean flag)                
    //设置窗体是否可见。
```
#### 1.2.2 取得屏幕大小
```java
    Toolkit.getDefaultToolkit().getScreenSize().width
    Toolkit.getDefaultToolkit().getScreenSize().height
```
#### 1.2.3 实现窗体显示在屏幕正中间：
```java
JFrame jf = new JFrame();

int w = Toolkit.getDefaultToolkit().getScreenSize().width
int h = Toolkit.getDefaultToolkit().getScreenSize().height
jf.setLocation((w - 200)/2, (h - 100)/2);   
```
#### 1.2.4 创建一个类继承JFrame
    创建一个构造方法，由构造方法初始化窗体。
    this.setXXX

#### 1.2.5 在main 方法中直接 new 一个继承JFrame 的类就ok。

### 1.3 JOptionPane 类
JOptionPane 用来弹出提示信息框，确认框和信息输入框。
不用new，直接调用静态方法就ok。

#### 1.3.1 弹出提示信息框
```java
JOptionPane.showMessageDialog(jf, "要提示的信息。");
```
#### 1.3.2 弹出确认框
```java
int result = JOptionPane.showConfirmDialog
                    (jf, "要确认的信息：正的要删除？");
是：0，否：1，取消：2 。                   
if(result == 0) {
    //显示一个提示框。已经删除。
}
if...
if...                   
```
#### 1.3.3 弹出信息输入框
```java
String message = JOptionPane.showInputDialog("请输入你的信息：");
if(message != null) {
    JOptionPane.showMessageDialog(jf, "信息：" + message);
} else {
    JOptionPane.showMessageDialog(jf, "请输入信息。");
}
            点取消的时候 message = null;
```
### 1.4 MouseListener 鼠标监听器接口
MouseListener 接收用户通过鼠标所做的操作。可以取得用户点击鼠标的坐标。
MouseListener 的使用方法：需要JFrame实现MouseListener接口，并由JFrame调用addMouseListener ()方法加入监听。

MouseListener接口的主要方法：
```java
1.mouseClicked(MouseEvent e)        监听鼠标点击事件。（鼠标不移动）
2.mousePressed(MouseEvent e)        监听鼠标按下事件。（使用频繁）
3.mouseReleased(MouseEvent e)        监听鼠标抬起事件。
4.mouseEntered(MouseEvent e)        监听鼠标进入事件。
5.mouseExited(MouseEvent e)            监听鼠标离开事件。
```
鼠标点击时执行的顺序：
mousePressed -> mouseReleased -> mouseClicked（按下与抬起在同一位置）

得到鼠标点击的坐标： MouseEvent 类。
```java
public void mousePressed(MouseEvent e) {
    System.out.println("点击位置：X-->" + e.getX());	//getX()：得到横向的点击坐标
    System.out.println("点击位置：Y-->" + e.getY());	//getY()：得到纵向的点击坐标
}
```
**由于MouseListener有很多动作，因此需要适配器类**

```java
		Button redButton = new Button("红色");

		// 对按钮添加鼠标的进入事件
		redButton.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseEntered(MouseEvent e) {
				f.setBackground(Color.RED);
			}
		});

		redButton.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseExited(MouseEvent e) {
				f.setBackground(Color.WHITE);
			}
		});
//注：这个鼠标监听器不仅仅只能加到按钮上，也可以加到窗体上
```

### 1.5 Graphics 类

Graphics 类似画笔，用来在窗口中绘制文字和图象。
通过重写JFrame 的 paint() 方法来使用，通过repaint() 方法来调用。

```java
例如：在JFrame中（也可以是继承自JFrame的自定义类）重写paint()方法：
    public void paint(Graphics g) {
    	//举例调用下面的这些方法，其他方法同样处理
    	g.drawString("Hello", 45, 50);
	}
```

Graphics————主要方法：

注：下面这些方法是通过在JFrame的paint()方法中，通过画笔对象g调用的

```java
1.drawString(String string, int x, int y):绘制字符串
    //字符串, x轴位置, y轴位置.
    //注意参数y指的是字符串整体的左下角点的位置
2.drawOval(int x, int y, int length, int hight):绘制一个空心圆。
    //x轴位置, y轴位置, 宽, 高  
    //注意：点（x, y）将会是此圆左上角的点
3.fillOval(int x, int y, int length, int hight):绘制一个实心圆
    //参数同上。
4.drawLine(int x1, int y1, int x2, int y2):绘制一条线
    //起点(x1, y1), 终点(x2, y2) 
    //用于画棋盘
5.drawRect(int x, int y, int width, int height):绘制一个空心矩形
    //x轴位置, y轴位置, 宽, 高：4参数   
6.fillRect(int x, int y, int width, int height):绘制一个实心矩形
    //参数同上
7.drawImage(BufferedImage img, int x, int y, JFrame jf):绘制一个已经存在的图片，将一个图片直接显示到窗体中。
    //img表示要导入哪张图片，x和y表示导入到哪个位置。jf表示导入到哪个窗体中

	（1）将硬盘中的图片导入到窗口中的思路：
		步骤1.通过ImageIO 输入一个BufferedImage
		步骤2.通过drawImage() 方法将一个BufferedImage 对象绘制到窗口中。       

	（2）实现导入一张图片的具体过程：
			把硬盘中图片读到内存，程序把图片从内存中取出，显示到窗体中。
    
			BufferedImage image = ImageIO.read(new File("文件路径＋文件"));
    	   		                         	  	 //IO要try...catch处理，因为可能读不到文件。
			g.drawImage(image, 0, 0, this);    	 //this 绘制到当前窗体下。
    	                      		     		 //如果没有背景，那么窗体是透明的。

/*注：
	1.窗体要设置的尽量大，能够放得下图片。否则窗体还是会透明，显示不出来图片
	2.必须要有这张图片，哪怕是一张纯白的也行。否则窗口将会是透明的
	3.图片可以自己画。win + S -> 搜索mspaint -> 画图
*/
```
### 1.6 其他会用到的方法
```java
1.setColor(Color c):设置画笔的颜色.Color类中有一些静态字段，对应一下常见的颜色，可以直接用。
    //需要导入Color类的包
2.setFont(Font f):设置文字的字体。需要和drawString()配合使用
/*
	1.举例：g.setFont(new Font("黑体", 40, 40));      
    	三个参数分别对应：字体，大小，大小
    	后面这两个大小具体不明确，可能一个是长度，一个是宽度
    2.此方法需要和drawString()配合使用：
*/
    	g.setFont(new Font("黑体", 40, 40));
    	g.drawString("五子棋游戏", 20, 100);

```
---

## 二、五子棋游戏的功能
2.1在点击鼠标时，可以在相应的位置显示棋子。
2.2 可以自动判断游戏是否结束，是否黑方或白方已经胜利。
2.3 对游戏时间进行设置，判断是否超出规定时间。

---

## 三、开发出游戏界面

创建FiveChessFrame 类，继承JFrame 实现MouseListener。
```java
public class FiveChessFrame extends JFrame implements MouseListener
```
### 3.1 FiveChessFrame的成员变量：width，height，bgImage

```java
    //屏幕大小：
int width = Toolkit.getDefaultToolkit().getScreenSize().width
int height = Toolkit.getDefaultToolkit().getScreenSize().height
    //背景图片：
BufferedImage bgImage = null;   
```

### 3.2FiveChessFrame的构造方法

```java
pubic FiveChessFrame() {
    this.setTitle("五子棋");
    this.setSize(500,500);        //背景图片大小。
    this.setLocation((width-500)/2, (height-500)/2);	//设置窗体出现的位置：在屏幕中央显示
    this.setResizable(false);	//锁定窗口大小
    this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);	//设置窗体关闭方式
    this.addMouseListener(this);   //加入鼠标监听。
    this.setVisible(true);

    try {
    	bgImage = ImageIO.read(new File("文件路径/文件"));	    //要用try...catch包裹起来
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    } 
    /*
    	我建议加入监听这个还是用刘意老师讲的那个，new一个适配器类，用匿名内部类实现：
    	这样用哪个就重写哪个，比较灵活。不然的话需要所有的都重写，太麻烦了
    	
    	举例：添加鼠标点击监听
            this.addMouseListener(new MouseAdapter() {
                public void mouseClicked(MouseEvent e) {
                    System.out.println("这是测试语句");
                }
    		});
    */
}
```
### 3.3重写paint()成员方法

+ 重写paint()方法的时候应该super(g);，清屏幕。否则会出现屏幕闪烁

```java
public void paint (Graphics g) {
//绘制背景图片。
    g.drawImage(bgImage, 1, 20, this);
//输出标题信息。   
    g.setFont(new Font("黑体", Font.BOLD, 20));
    g.drawString("游戏信息：", 120, 60);
//输出时间信息。
    g.setFont(new Font("宋体", 0, 14));
    g.drawString("黑方时间：无限制", 30, 470);   
    g.drawString("白方时间：无限制", 260, 470);   
/*
	技巧：用鼠标点击的方式获取窗口中某一点的坐标
		在mousePressed(MouseEvent e)  方法中打印坐标。
		System.out.println("X:" + e.getX());
		System.out.println("Y:" + e.getY());
*/               

/*
	计算棋盘中每一条线的间距：
		使用 19X19 的围棋棋盘。
		横 19 条线，纵 19 条线。
		总宽度 360 像素，分成18 份，每份 20 像素。
		总高度 360 像素，分成18 份，每份 20 像素。
*/
//绘制棋盘
    for(int i=0; i<19; i++) {
        g.drawLine(10, 70 + 20 * i, 370, 70 + 20 * i);	//横向
        g.drawLine(10 + 20 * i, 70, 10 + 20 * i, 430);	//纵向
    }   

//标注点位。加粗。    注意x, y 不是圆心坐标，而是左上角的坐标。3X3 位置。
    g.fillOval(68,128,4,4);        //四角
    g.fillOval(308,128,4,4);
    g.fillOval(308,368,4,4);
    g.fillOval(68,368,4,4);       

    g.fillOval(308,248,4,4);    //四边
    g.fillOval(188,128,4,4);
    g.fillOval(68,248,4,4);
    g.fillOval(188,368,4,4);
       
    g.fillOval(188,248,4,4);    //中心
}
```
```java
public static void main(String [] args) {
    FiveChessFrame ff = new FiveChessFrame();
}
```

---

## 四、实现下棋功能

在棋盘上的鼠标点击位置，显示一个棋子。

黑子：一个实心的黑圆。
白子：一个空心的黑圆 +  一个实心的白圆。
repaint() 方法：重新执行一次paint() 方法。通过JFrame对象来调用，如果当前类将是JFrame对象，就直接this.repaint()

### 4.1 添加新的成员变量

#### 4.1.1 定义一个成员变量保存棋子的坐标

```java
//在成员变量位置添加：
int x = 0;
int y = 0;
```
#### 4.1.2通过二维数组保存之前下过的所有棋子的坐标
//如果其中数据内容     0：表示这个点没有棋子；
                1：表示这个点是黑子；
                2：表示这个点是白子。

```java
//在成员变量位置添加：
int[][] allChess = new int[19][19];

/*
	如果其中数据内容为：
		0：表示这个点没有棋子；
		1：表示这个点是黑子；
		2：表示这个点是白子。
*/
```
#### 4.1.3 判断下一步下黑子，还是下白子

开局黑子先下

```java
//在成员变量位置添加：
boolean isBlack = true;
```
### 4.2 完善paint ()方法：绘制全部棋子

```java
public void paint() {
	/**......接着上面的补充*/
//输出二维数组中所有的数值。一重循环，循环行，二重循环，循环列。
//画线的时候，已经循环了坐标。

//输出二维数组中全部棋子。
    for(int i=0; i<19; i++) {
        for(int j=0; j<19; j++) {
            if(allChess[i][j] == 1) {
                //黑子，把坐标恢复成像素
                int tempX = i * 20 + 10;    //10 是棋盘外横向左侧空了10 像素
                int tempY = j * 20 + 70;	//70 是棋盘外纵向上侧空了70像素
                g.fillOval(tempX - 7, tempY - 7, 14, 14);	
                //减7是因为这里的参数对应的是左上角的坐标，而不是中心点
            }       
            if(allChess[i][j] == 2) {
                //白子，把坐标恢复成像素
                int tempX = i*20+10;
                int tempY = j*20+70;
                g.setColor(Color.white);
                g.fillOval(tempX-7, tempY-7, 14, 14);
                g.setColor(Color.black);
                g.drawOval(tempX-7, tempY-7, 14, 14);
            }   
        }
    }
}
```
### 4.3 完善鼠标监听器的功能：把棋子保存到相应的位置

```java
public void mousePressed(MouseEvent e) {
    x = e.getX();
    y = e.getY();   
    if( x>= 10 && x <= 370 && y >= 70 && y <= 430) {	//判断鼠标是否在棋盘范围内点击
	/*
		判断x, y 距离哪个交叉点最近。把坐标保存到二维数组中。
		一大难点。要下棋子的坐标。
	*/
        //把像素转换为坐标：
        x = (x - 10) / 20;        //10 是棋盘外面多余部分。
        y = (y - 70) / 20;        //同样，70是棋盘外面的部分。除后取整。不准确。
       
	//位置是空的才能下，不然会覆盖原来下的棋子颜色。
        if(allChess[x][y] == 0) {       
	//判断当前下什么颜色的棋子。       
            if(isBlack == true) {
                allChess[x][y] = 1;
                isBlack = false;
            } else {
                allChess[x][y] = 2;
                isBlack = true;
            }
        } else {
            JOptionPane.showMessageDialog
                    (this,"当前位置已经有棋子， 请重新落子");
        }
        this.repaint();        
    }
}
/*
	我自己的理解：
		可以把相关数据都定义成静态变量放到一个接口中，让自定义窗口类实现这个接口
		编写程序的时候只通过变量名使用。
		然后运行之前给接口的所有参数赋值。
		这样可以实现程序的扩展性。并且后期修改时只修改接口数据即可。
*/
```

下面这段是原作者自己的分析：我觉得他还是没有理解透彻。不能这样死记硬背。

```java
分析 画棋子部分：
显示棋子分两步，输入(mousePressed)＋输出(paint)。
x = (x - 10) / 20 * 20 + 10;
(x - 10) / 20 保存

* 20 + 10 输出

int tempX = i * 20 + 10;
```

---

## 五、判断输赢（结合下面第十一章一起看）
五子棋规则：判断是否有同一颜色的棋子连成5 个。
判断当前下的棋子，跟周围相连的相同的棋子是否有5 个。

### 5.1 完善鼠标监听器的功能
在mousePressed 方法中第一个if 最后面添加判断。（保证能落子）
```java
//判断这个棋子是否和其他的棋子连成5连，即判断游戏是否结束。
boolean winFlag = this.checkWin();

if(winFlag == true) {
    JOptionPane.showMessageDialog(this, "游戏结束，" +
    (allChess[x][y]==1?"黑方":"白方") + "获胜！" );	
    //老师这里采用的方法是看最后一步下的棋的颜色，因为最后那一步棋一定是赢的人下的
    canPlay = false;
}
```
### 5.2 单独写一个判断方法checkWin()
要判断4 个方向。

基本思路：（后期被改进）

```java
//这是初始的基本思路，后期被改进了。
//这个仅是用来判断横向的输赢情况的。
//由于判断其他方向的代码太多，因此把“判断某个方向最大连接棋子数”的代码提取成方法checkCount()（见第六部分）
//然后每个方向都调用一遍checkCount()。
private boolean checkWin() {
	boolean flag = false;
    int count = 1;	//保存共有相同颜色多少棋子相连。默认最开始这个也算一个，所以是从1开始计数
    int color = allChess[x][y];
	int i = 1;
    /*  
    	分析:
			判断横向是否有5 个棋子相连，
		特点：纵坐标是相同的，即allChess[x][y]中y 值是相同的。
   			int color = allChess[x][y];     //判断颜色。
			通过循环来做棋子相连的判断。

    */
	while(color == allChess[x + i][y]) {	//判断棋子的右侧，如果发现颜色不一样了，就不再判断了。
    	count++;
    	i++;
	}
	i = 1;
	while (color == allChess[x - i][y]) {	//判断棋子的左侧，如果发现颜色不一样了，就不再判断了。
    	count++;
    	i++;
	}
	if (count >= 5) {	//两侧都判断完之后，如果发现这一条线上连续相同颜色的超过5个，说明已经有一方赢了
    	flag = true;
	}
	return flag;
}
```

我自己对每个方向的判断条件的理解：

```java
/*
	初始设定i = 1，在方法中每循环一次，i会自增1
	横向：
		allChess[x + i][y] -> [x + i][y + 0]
		allChess[x - i][y] -> [x - i][y - 0]
		
			=>	1, 0
	纵向：
		allChess[x][y + i] -> [x + 0][y + i]
		allChess[x][y - i] -> [x - 0][y - i]
		
			=>	0, 1
	45°：
		allChess[x + i][y + i]
		allChess[x - i][y - i]
		
			=>	1, 1
	135°
		allChess[x + i][y - i]
		allChess[x - i][y + i]
		
			=>	1, -1
		
	把这两个参数抽象成a, b之后，就可以写一个方法：
		allChess[x + a][y + b]
		allChess[x - a][y - b]
	其中a的取值只能是0或1。而b则可能为0， 1， -1
	并且当某一个取值为0时，将不会执行自增自减。取值为1时，执行自增。取值为-1时，执行自减
	
	老师写的关于其他方向的判断基于这种思路。见第六部分的checkCount()方法
*/			
```



被替代后的代码：

```java
private boolean checkWin() {
    boolean flag = false;
//保存共有相同颜色多少棋子相连
    int count = 1;   


    /*  
    	分析:
			判断横向是否有5 个棋子相连，
		特点：纵坐标是相同的，即allChess[x][y]中y 值是相同的。
   			int color = allChess[x][y];     //判断颜色。
			通过循环来做棋子相连的判断。

    */
    count = this.checkCount(1, 0, color);        //横判断
    if(count >= 5) {
        flag = true;
    } else {
        count = this.checkCount(0, 1 ,color);    //纵判断
        if(count >= 5) {
            flag = true;
        } else {
            //判断右上，左下，x 加，y 减。
            count = this.checkCount(1, -1, color);
            if(count >= 5) {
                flag = true;
            } else {
                //判断右下，左上，x 加， y 加；x 减， y 减。
                count = this.checkCount(1, 1, color);
                if(count >= 5) {
                    flag = true;
                }
            }
        }
    }      
    return flag;
}
//这种算法，经常使用（横，竖，斜），如扫雷。
```

### 5.3 再添加一个新的成员变量：canPlay
用于标识当前游戏是否可以继续
```java
boolean canPlay = true;
```

### 5.4 mousePressed 所有的代码加一个判断：当游戏结束时，不允许再下棋
```java
if(canPlay == ture) {
    //之前写的mousePressed里的所有代码移到这里。
}
	//也可以if(!canPlay) return;    马士兵的风格。
```
---

## 六、将判断输赢的方法整合成一个方法：checkCount()

//判断棋子连接的数量。参数：x轴，y轴变化的数字。
//重复的代码提取成一个方法。

```java
private int checkCount(int xChange, int yChange, int color) {
    int count = 1;
    //temp用于记录Change的值。执行完循环之后Change的值可能改变，
    //而此时只进行了一半的判断，因此需要恢复Change后判断另一半
    int tempX = xChange;
    int tempY = yChange;
    while(color == allchess[x+xChange][y+yChange]) {
        count++;
        if(xChange != 0) xChange++;
        if(yChange != 0) {
            if(yChange > 0) {
                yChange++;
            } else {
                yChange--;
            }       
        }
    }       

    xChange = tempX;
    yChange = tempY;        //变回初始值，再判断相反方向。
       
    while(color == allchess[x-xChange][y-yChange]) {
        count++;
        if(xChange != 0) xChange++;
        if(yChange != 0) {
            if(yChange > 0) {
                yChange++;       
//yChange 如果是－1 加加就是0 了。多加了一个bug。所以应该是减减
            } else {
                yChange--;
            }       
        }
    }   

    return count;
}
```

---

## 七、显示游戏信息：轮到谁下了

### 7.1 定义一个新的成员变量：message

用于保存显示的提示信息。

```java
    String message = "黑方先落子 ";
```

### 7.2 paint ()方法中： 游戏信息字符串后面加上提示信息

```java
 g.drawString("游戏信息：" + message, 130, 60);
```

### 7.3 完善鼠标监听器的功能：根据走子，改变提示信息

`public void mousePressed(MouseEvent e) `方法中添加：

```java    
if(isBlack == true) {
	allChess[x][y] = 1;
	isBlack = false;
	message = "轮到白方";
} else {
	allChess[x][y] = 2;
	isBlack = true;
	message = "轮到黑方";               
}
```

---

## 八、处理屏幕闪烁问题：在paint()方法中添加双缓冲

双缓冲技术：一般用于手机游戏中。原因是手机的内存相对较小，屏幕闪烁问题比较明显。
解决方法：
把所有要显示到屏幕上的信息，先缓冲到内存中的图片上，
再统一把内存中的图片显示到窗体中。

在`paint()`方法中添加双缓冲：

```java
//在第一条语句上添加：
BufferedImage bi = new BufferedImage(500,500,BufferedImage.TYPE_INT_ARGB);    //传入一个颜色类型
Graphics g2 = bi.createGraphics();    //为内存中的bi 图片创建画笔。

中间的g都改成用g2 画到缓冲图片上，g只用于画bi。

....
    
//paint()方法的结尾处最后添加一句：    
g.drawImage(bi,0,0,this);
```
一次性绘制的东西太多，可以会先绘制一些，后绘制一些。
程序很快执行，就会出现闪烁。
双缓冲，只画一个，就把上面的内容一次性绘制到程序中。

---

## 九、加入按钮功能

### 9.1 打印出坐标，用于通过鼠标点击找按钮范围的像素

```java
System.out.println(e.getX() + "--" e.getY());
```

### 9.2 按钮区域

```java
开始游戏：重新开始新的游戏。       
游戏设置：设置倒计时。
游戏说明：说明游戏规则和操作。
认输：    某一方放弃游戏，认输。
关于：    显示程序的作者或编写单位的相关信息。
退出：    结束程序。
```

因为我所有的按钮都是在同一列上的，所以 x 轴坐标不用改，只需要改纵坐标y。

在`public void mousePressed(MouseEvent e)` 方法最后添加下面的所有代码：

```java
//点击 开始游戏 按钮
if(e.getX() >= 400 && e.getX() <= 470 && e.getY() >= 70 && e.getY() <= 100) {
    int result = JOptionPane.showConfirmDialog(this,"是否重新开始游戏？");
    if(result == 0) {
        /*
			重新开始游戏：
				1.把棋盘清空，allChess数组中全部数据归0。
				2.将游戏信息的显示改回到开始位置。
				3.将下一步下棋的人改为黑方。
		*/
        //1.清空棋盘
        for(int i=0; i<19; i++) {
            for(int j=0; j<19; j++) {
                allChess[i][j] = 0;
            }
        }
        //另一种清空二维数组方式 allChess = new int[19][19];
        //2.重置游戏信息
        message = "黑方先落子";
        //3.将下一步下棋的人改为黑方。
        isBlack = true;
        //清空棋盘。清空东西后，重新刷一遍，页面显示才会变化。
        this.repaint();           
    }       
}

/*-------------------------------------------------------------------------------------------------*/

//点击 游戏设置 按钮   
if(e.getX() >= 400 && e.getX() <= 470 && e.getY() >= 120 && e.getY() <= 150) {
	String input = JOptionPane.showInputDialog("请输入游戏的最大时间(单位：分钟)，如果输入0，表示没有						时间限制：");
	try {
		maxTime = Integer.parseInt(input)*60;    //添加try 块。
		if(maxTime < 0) {
			JOptionPane.showMessageDialog(this, "请输入正确信息，不允许输入负数！");
		}
		if(maxTime == 0) {
			int result = JOptionPane.showConfirmDialog(this, "设置完成，是否重新开始游戏？");
			if(result == 0) {
				//代码和游戏开始相同。
				//......//1.清空棋盘	2.重置信息	3.改黑方
				blackTime = maxTime;
				whiteTime = maxTime;       
				//给重新开始游戏那也加上2 行代码
				blackMessage = "无限制";
				whiteMessage = "无限制";
				this.canPlay = true;                    
				this.repaint();
			}               
		}
		if(maxTime > 0) {
			int result = JOptionPane.showConfirmDialog(this, "设置完成，是否重新开始游戏？");
			if(result == 0) {
				//代码和游戏开始相同。
				//......//1.清空棋盘	2.重置信息	3.改黑方
				blackTime = maxTime;
				whiteTime = maxTime;
				blackMessage = maxTime / 3600 + ":" + (maxTime / 60 - maxTime / 3600 * 60) + ":" + 									(maxTime - maxTime / 60 * 60);
				whiteMessage = maxTime / 3600 + ":" + (maxTime / 60 - maxTime / 3600 * 60) + ":" + 									(maxTime - maxTime / 60 * 60);
				t.resume();            //启动挂起的线程。
				this.canPlay = true;    
				//开始游戏代码中判断，if(maxTime > 0) {} else {}
				//有时间限制用这一段，没有时间限制用maxTime == 0 那段。               
				this.repaint();
			}
		}
	} catch (NumberFormatException e) {
		JOptionPane.showMessageDialog(this,"请正确输入信息！");
	}   
}
                                           
/*-------------------------------------------------------------------------------------------------*/

//点击 游戏说明 按钮   
if(e.getX() >= 400 && e.getX() <= 470 && e.getY() >= 170 && e.getY() <= 200) {
	JOptionPane.showMessageDialog(this,"这是一个五子棋游戏，黑白双方轮流下棋，当某一方连到5 子时，游戏结				束。");
}
                                           
/*-------------------------------------------------------------------------------------------------*/

//点击 认输 按钮   
if(e.getX() >= 400 && e.getX() <= 470 && e.getY() >= 270 && e.getY() <= 300) {
	int result = JOption.showConfirmDialog(this, "是否确认认输？");
	if(result == 0) {
		if(isBlack) {
			JOptionPane.showMessageDialog(this,"黑方已经认输，游戏结束")    ;
		} else {
			JOptionPane.showMessageDialog(this,"白方已经认输，游戏结束")    ;
		}
	}
	canPlay = false;
}
                                           
/*-------------------------------------------------------------------------------------------------*/
                                           
//点击 关于 按钮   
if(e.getX() >= 400 && e.getX() <= 470 && e.getY() >= 320 && e.getY() <= 350) {
	JOptionPane.showMessageDialog(this, "本游戏由MLDN制作，有相关问题可以访问www.mldn.cn");
}
                                           
/*-------------------------------------------------------------------------------------------------*/
                                           
//点击 退出 按钮   
if(e.getX() >= 400 && e.getX() <= 470 && e.getY() >= 370 && e.getY() <= 400) {
	JOptionPane.showMessageDialog(this, "游戏结束");
	System.exit(0);
}   

```

---

## 十、通过线程操作实现游戏设置中的倒计时

### 10.1 添加与时间相关的成员变量：maxTime，blackTime，whiteTime，blackMessage，whiteMessage，thread

用于保存最多拥有多少时间（秒）：

```java
int maxTime = 0;
```

保存黑方和白方的剩余时间：

```java
int blackTime = 0;
int whiteTime = 0;
```
保存双方剩余时间的显示信息：

```java
String blackMessage = "无限制";
String whiteMessage = "无限制";
```
在成员变量中定义一个线程类。

```java
Thread t = new Thread(this);    //对当前窗体做线程控制。
```

**注意，在定义线程之前，需要当前的整个五子棋类实现Runnable接口**

```java
//实现Runnable的方法：

public class FiveChessFrame extends JFrame implements MouseListener, Runnable {
    //...所有代码
}
```

### 10.2 在构造方法中设置线程启动

```java
//在构造方法中添加下列代码以启动线程：
t.start();
t.suspend();            //在线程启动后，先将线程挂起
```

### 10.3 在五子棋类中重写Runnable接口的run() 方法，实现线程

```java
public void run() {
	//判断是否有时间限制
	if(maxTime > 0) {
		while(true) {
			if(isBlack) {
				blackTime--;
				//超时判断。
				if (blackTime == 0) {
					JOptionPane.showMessageDialog(this, "黑方超时,游戏结束!");
				}
			} else {
				whiteTime--;
				//超时判断。
				if (whiteTime == 0) {
					JOptionPane.showMessageDialog(this, "白方超时,游戏结束!");
				}
			}
			blackMessage = blackTime / 3600 + ":" + (blackTime / 60 - blackTime / 3600 * 60) + ":" + 							(blackTime - blackTime / 60 * 60);
			whiteMessage = whiteTime / 3600 + ":" + (whiteTime / 60 - whiteTime / 3600 * 60) + ":" + 							(whiteTime - whiteTime / 60 * 60);
			this.repaint();                //刷新屏幕，重新调用paint 方法。
			try {
				Thread.sleep(1000);            //1000毫秒，即1秒。要try 。
			} catch () {
				e.printStackTrace();
			}
		}       
	}
}   
```

### 10.4 显示倒计时。修改paint 方法。

```java
g2.drawString("黑方时间："+blackMessage,30,470);
g2.drawString("白方时间："+whiteMessage,260,470);   
```

---

## 十一、第一次运行出现黑屏的原因与解决办法

原因：paint 方法不是最后执行的。
解决：在构造方法线程挂起那条语句后面，try...catch块前面，手工调用 repaint() 方法。刷新屏幕

```java
this.repaint();
```



---

## 十二、棋子下到最边缘的位置，报数组下标越界错误

原因：在checkCount()方法中 连接数量判断的时候，没有考虑位置为0。位置为0 再减 1 就是 －1 下标越界了。
解决：在while里多加一个判断。

**上半部分：**

加判断之前的：

我写的这个，xchange就是a，ychange就是b

```java
while(color == allChess[x+xChange][y+yChange])
```

**加完判断之后的：（对比）**

```java
while(x+xChange>=0 && x+xChange<=18 && y+yChange>=0 && y+yChange<=18 && color == allChess[x+xChange][y+yChange])       
```

**同理，下半部分判断：加变成减。**

```java
while(x-xChange>=0 && x-xChange<=18 && y-yChange>=0 && y-yChange<=18 && color == allChess[x-xChange][y-yChange])
```

---

## 我自己的草稿纸：

 ### 1. 如何加载一张图片？

```java
public class MyJFrame extends JFrame {
    Image img = null;
    Image img2 = null;
	public MyJFrame {
        img = new ImageIcon(MyFrame.class.getResource("tx.jpg")).getImage();	//我自创的方式
        img2 = new ImageIcon("11.jpg").getImage();	//Java核心技术里面用的方式
    }
    
    public void paint(Graphics g) {
        g.drawImage(img, 10, 10, null);
    }
}

```

### 2. 双缓冲技术，重写Component类中的update()方法？

+ https://bbs.csdn.net/topics/390659465 

### 3. 相对路径与绝对路径？

+ 绝对路径：前面加一条 / ，相当于当前的项目  

### 4. paint()与paintComponent()的区别？

```java
Swing中改变组件样式重写paintComponent就可以了，其他paintBorder和paintChildren默认就可以。awt中改变组件样式要重写paint方法，而且如果不需要调用super.paint(g)就可以保留原组件样式，但是不会显示子组件样式，可以调用paintComponents(g)解决这个问题。
```

```java
1 - paint() 中调用 paintComponent(), paintBorder(), paintChildren()

2 - 最重要的区别是“双缓冲”。Swing 组件的 paint() 中实现了双缓冲，所以不要随便去覆写，会破坏双缓冲的，————建议的方式是覆写 paintComponent()，很多人做的小程序会”闪烁“，就是因为他们覆写了 paint() 方法，破坏了Swing本身的双缓冲。Swing 不建议用户自己实现双缓冲。

3 - 覆写 paint()，如果新方法没有去调用 paintChildren()，还会造成子控件不显示，鼠标移上去才显示，这个也是很多新手问的问题： “为什么我的按钮只有鼠标移上去才显示？”

4 - 只有极少数的情况可能需要覆写 paint() 方法，通常是为了实现特殊的绘图效果，或者特殊的优化，比如 JViewport 覆写了 paint() 方法，使用“延迟重绘”的方式来合并当滚动条移动时一些特别频繁的重绘请求，等等。
```