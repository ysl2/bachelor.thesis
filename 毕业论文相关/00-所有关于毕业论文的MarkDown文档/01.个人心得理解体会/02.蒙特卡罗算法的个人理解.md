通过阅读和整理文献并结合代码试运行，我已经：

1.明确了五子棋的博弈规则。在本次设计中为了使算法能够最大程度地发挥，我们采用gomocup中的Free-Style规则：棋盘为15 * 15，电脑为先手方、不做禁手、长连算赢。

2.明确五子棋的判断逻辑。五子棋判断胜负的一种方式是根据水平、竖直、45°和135°的线上是否有下一步落子能构成五子连珠的位置。如果有，则已经分出胜负。所以可以通过提前若干步预判棋局的当前状况来提高算法的智能度。

下一步计划再做的工作：

1.明确类与类之间的调用关系、明确每个类实现的功能、明确返回值类型与参数列表。目前我简单地分成了以下几个部分：棋手类（实现通用功能）、人类棋手类（继承自棋手类）、电脑棋手类（继承自棋手类）、AI类（用于在电脑棋手类实现）、棋盘类、裁判类（用于判断输赢）、引擎类（聚合上面这些类，也是main方法所在的类）。随着研究深入，可能需要进一步定义接口。

2.明确AI类中蒙特卡洛方法的具体实现：

蒙特卡洛方法主要步骤是：搜索、模拟、反向传播。对于给定的一个点，向下遍历此点在博弈树中对应的子节点的位置，并对这些子节点模拟得出一个可作为评判优劣的值，然后将此值反向传播回最开始的那个点。在传播过程中，还会对传播路径上所有的点对应的值进行更新。最后返回的是值最优的节点，即下一步棋要走的位置。但是通过蒙特卡洛方法得到的最优值仅是局部最优，很难得到全局最优点，因为计算时间和电脑的算力都是有限的。

首先是参数与返回值：蒙特卡洛方法需要传入一个棋子对应的二维数组的坐标，返回的也是一个二维数组坐标。

蒙特卡洛方法内部，是由以下几部分部分构成：

（1）.搜索方法：如果传入的这个二维坐标对应的博弈树没有完全展开，就挑一个未访问的子节点返回。如果已经完全展开，就直接返回这个点的

（2）.模拟方法：也就是rollout策略函数。这一步是根据某种策略来计算从搜索方法传来的节点的模拟奖励和访问次数

（3）.反向传播方法：将已经完成模拟的节点rollout值通过“更新方法”计算出这个节点的传播给博弈树中的根节点，也就是输入的那个二维数组的坐标

（4）.用于最后做出判断的方法：

（5）.更新方法：由反向传播方法调用。这个方法是用来更新传播路径上的每个节点的数据，一直传到根节点停止

（6）.UCT函数：用于控制

（7）.最后，蒙特卡罗方法需要一个主方法来包裹上面这些步骤，并对主方法的耗时和算力进行限制

