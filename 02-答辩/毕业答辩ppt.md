## **各位评委老师好：**

我是16级金信1班的于松黎，导师是赵志崑老师

下面我将从论文选题、系统演示和论文内容三方面进行自述**（🔺）**

## **1.首先是论文选题：**

五子棋游戏历史悠久，并且非常大众化，游戏规则明确，而且玩法也很成熟

蒙特卡洛树搜索方法在棋类游戏的应用中十分广泛，并且不会受到特定棋类的限制，因此通过五子棋来研究蒙特卡洛树搜索算法，具有现实意义。**（🔺）**

## **2.下面我演示一下系统。**

1.落子，快速点，“电脑正在考虑，请等一会儿”

2.先点几下中间的棋，“已经有棋了，请在别的地方下”

3.让黑棋赢，然后点其他地方，“胜负已分，请重置棋盘”

4.重置棋盘

## **（🔺）3.我的论文分为四个部分（🔺）**

首先是第一部分，这部分是关于蒙特卡洛树搜索方法以外的，其他常用搜索方法。（🔺）主要阐述了权值法和极大极小两种博弈算法，并简单地比较了两种算法的优劣情况。权值法的实现方式比较简单，但是智能度很低，只能针对当前的局面进行判断，却无法继续预测后续的局面。极大极小算法虽然智能度很高，但是需要程序员十分了解相应的游戏规则，然后自己定义每一种局面的评价标准，因此会受到特定棋类的限制，并且很难预测更复杂的局面。而蒙特卡洛树搜索算法可以解决这些问题。（🔺）

第二部分是蒙特卡洛方法概述。（🔺）在这一部分中，我研究了蒙特卡洛方法、蒙特卡洛树搜索算法、UCT算法之间的区别和联系。（🔺）蒙特卡洛方法是一种基于随机模拟的统计学方法，不仅在棋类游戏中使用，在其他领域应用也十分广泛。（🔺）而蒙特卡洛树搜索算法，则是将蒙特卡洛方法应用于棋类游戏中的博弈方法，分为选择、扩展、模拟和反向传播四个部分。（🔺）通过第一步选择步骤选出值得模拟的节点，如果当前状态不能选择，就通过第二步扩展步骤得到节点。然后通过第三步模拟步骤得出当前节点的胜率，最后通过第四步将胜率反向传播到根节点。上述四个步骤会循环执行，直到算力到达极限或到达规定时间为止。（🔺）由于蒙特卡洛树搜索缺少最关键的选择步骤，因此无法直接实际应用。而UCT算法是在蒙特卡洛树搜索算法的基础上，加入了UCB算法的选择思路后形成的。（🔺）虽然和蒙特卡洛树搜索方法类似，但是UCT方法的主要区别在于第一步中的选择步骤里有了一个可实际应用的算法支持。本设计也是通过UCT算法实现的。（🔺）

第三部分是程序的具体实现过程。整个实现过程包括算法和界面两部分。（🔺）在算法部分中，树策略主要由这三个方法构成。其中第三个方法是调用UCT公式计算节点，判断节点的优劣。核心点在于前两个方法。（🔺）第一个方法是获得可选择的行动组，是遍历棋盘每一行，得到空点放入链表集合后打乱顺序得到的。（🔺）第二个方法是获取子节点集合，是在链表中弹出一个局面，形成结点后放入哈希表中得到的。通过以上三个方法完成了UCT算法的第一个步骤，也就是树策略部分。（🔺）在界面部分中，程序判断游戏胜负的方法按照权值法的思路，实现方法是先判断棋子的八个方向上是否已经连成五个，如果没有，那么累计变量加1。直到等于棋盘格子数，就平局。否则继续下棋。（🔺）并且我把电脑下棋作为一个新的线程启动，这样可以保证当算法运行时，对于玩家连续点击棋盘的动作可以给出提示信息，而不是无响应状态。（🔺）

第四部分是系统测试分析。（🔺）在五子棋程序完成后，由于搜索次数不足，算法在较高棋盘维度情况下，智能度降低。而加大搜索次数将导致计算时间增加，影响算法性能。因此在第四部分中，针对算法效率进行测试与分析，目的是在搜索次数、判断标准与棋盘大小之间找到平衡点。尽量在棋盘较大的情况下保持性能与智能度。（🔺）

并且考虑到游戏开局时，需要遍历的节点很多，我在极大极小算法的迭代加深优化的启发下，在程序完成后又添加了一个迭代深化搜索方法。这个方法的目的是减少开局时的搜索次数，并随着游戏发展逐渐增加搜索次数。因此我记录了场上棋子数量，并且将其作为搜索步进。通过这个改良，能够节省大量开局搜索时间。（🔺）

## **4.结束语**

以上是我的汇报内容，请各位老师批评指正。